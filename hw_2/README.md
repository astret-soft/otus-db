# Добавляем в модель данных дополнительные индексы и ограничения
## Задание
1. Проводим анализ возможных запросов\отчетов\поиска данных.
2. Предполагаем возможную кардинальность поля.
3. Создаем дополнительные индексы - простые или композитные.
4. На каждый индекс пишем краткое описание зачем он нужен (почему по этому полю / полям).
5. Думаем какие логические ограничения в БД нужно добавить - например какие поля должны 
быть уникальны, в какие нужно добавить условия, чтобы не нарушить бизнес логику. 
Пример - нельзя провести операцию по переводу средств на отрицательную сумму.
6. Создаем ограничения по выбранным полям.

# Анализ возможных запросов, отчетов, поиска данных
* Для всех отношений (многие к многим, один к одному (foreign key в данном случае делается уникален и т.д.) нужно предоставлять для foreign key 
индексацию для осуществления большей доступности по времени запросов SELECT. (1)
* Сущности User нужны композитные индексы: такие как пара username, password_hash дадут прирост скорости при авторизации. (2)
* Приватный ключ уже является индексом и он уникален. (3)
## Администратор
* Какие пользователи обладают следующими привилегиями (правами) и сколько их: используем (1) и (2)
* Кто есть из пользователей на сцене, включая фильтрацию по времени, когда будет действовать сцена: (1) и (2)
* Какие пользователи использовали методы для определения своей локации на схеме (их популярность) и другое (статистика для определения популярных методов): (1) и (2)
* Поиск сцены по описанию (поле Scene.description) для поиска ближайших активностей с действующей на текущий момент сцены: (1), (2) и поле description индексируем по FTS согласно https://www.postgresql.org/docs/current/textsearch-tables.html
* Запрос на получение кадров из сцены: (1)
## Пользователь
> Пользователь не использует какой-либо функционал, кроме базового (авторизация, получения себя на сцене или добавления к ней, получение текущего кадра)
* Поиск сцены, где он зарегестрирован, включая поиск по ее названию и описанию (Scene.description по FTS) и регистрация на новой сцене: (1) и (2)
* Получение и редактирование его текущей позиции на сцене (пиксель): (3) но данную сущность лучше запоминать в БД типа Redis или Memcached для большей доступности и скорости, т.к. это временная таблица, а информацию с историей лучше хранить в отдельной БД для логирования. 
* Получение кадров из сцены: (3)
# Индексы и ограничения
> Предполагается, что большую часть по валидации возьмет на себя backend, чтобы уменьшить число миграций над БД, но есть общие правила: 
> * избегаем NULL, т.е. если поле строка то лучше "" (пустая строка).
> * поле Scene.JSONB не валидируем, т.к. считаем полем, которое будет часто менять схему и нет необходимости по ней проводить регулярный поиск.
> * Задействуем FTS, встроенный в PostgreSQL, т.к. это снизит необходимость дублирования и будет консистентность данных для таких запросов, по сравнению с ElasticSearch, Sphinx и т.д.
> * Для полей с небольшой кардинальностью, например поле User.gender: значения Male / Female и их встречаемость примерно равна - здесь нет смысла делать индекс, т.к. н все равно не будет задействован (более дорогой, чем поиск перебором)

## Замечания
> Через ANALYZE проверяем, что поиск идет в частых запросах как надо,
> и, если нет - то обращаемся к документации и находим правильный индекс (например расширяем ).
> По факту смотрим как БД себя ведет в зависимости от обьема данных и их кардинальности.
''